import type { ParsedComponent } from "./css-parser";

const HEADER = "// AUTO-GENERATED by @versaur/tooling â€” DO NOT EDIT";

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function toPascalCase(s: string): string {
  return s.split(/[-_]/).map(capitalize).join("");
}

function toCamelCase(s: string): string {
  const parts = s.split(/[-_]/);
  return parts[0] + parts.slice(1).map(capitalize).join("");
}

/**
 * Generate the `.types.generated.ts` file content for a parsed component.
 */
export function generateTypesFile(parsed: ParsedComponent): string {
  const pascal = toPascalCase(parsed.componentName);
  const lines: string[] = [
    HEADER,
    `// Source: ${parsed.componentName}.module.css`,
    "",
  ];

  // Enumerated type aliases
  const enumTypeNames: { attrName: string; typeName: string }[] = [];
  for (const [attrName, values] of parsed.enumeratedAttrs) {
    const pascalAttr = toPascalCase(attrName);
    const typeName = `${pascal}${pascalAttr}`;
    const union = [...values]
      .sort()
      .map((v) => `'${v}'`)
      .join(" | ");
    lines.push(`export type ${typeName} = ${union};`);
    enumTypeNames.push({ attrName, typeName });
  }

  if (enumTypeNames.length > 0) lines.push("");

  // DataAttrs interface
  lines.push(`export interface ${pascal}DataAttrs {`);
  for (const { attrName, typeName } of enumTypeNames) {
    const propName = toCamelCase(attrName);
    lines.push(`  ${propName}?: ${typeName};`);
  }
  for (const attrName of [...parsed.booleanAttrs].sort()) {
    const propName = toCamelCase(attrName);
    lines.push(`  ${propName}?: boolean;`);
  }
  lines.push("};");
  lines.push("");

  // Namespace
  lines.push(`export namespace ${pascal} {`);
  for (const { attrName, typeName } of enumTypeNames) {
    const pascalAttr = toPascalCase(attrName);
    lines.push(`  export type ${pascalAttr} = ${typeName};`);
  }
  lines.push(`  export type DataAttrs = ${pascal}DataAttrs;`);
  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate the `.module.css.d.ts` file content for a parsed component.
 */
export function generateCssDtsFile(parsed: ParsedComponent): string {
  const lines: string[] = [HEADER, "declare const styles: {"];

  for (const className of parsed.classNames) {
    const key = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(className)
      ? className
      : `'${className}'`;
    lines.push(`  readonly ${key}: string;`);
  }

  lines.push("};");
  lines.push("export default styles;");
  lines.push("");

  return lines.join("\n");
}
